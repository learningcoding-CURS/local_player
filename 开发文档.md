# 开发文档

本文档提供项目的详细开发说明和技术细节。

## 技术架构详解

### 1. MVVM 架构

```
┌─────────────────────────────────────────────┐
│              UI Layer (Compose)              │
│  ┌──────────────┐      ┌──────────────┐    │
│  │ PlayerScreen │      │LibraryScreen │    │
│  └──────────────┘      └──────────────┘    │
└──────────────┬──────────────┬───────────────┘
               │              │
┌──────────────▼──────────────▼───────────────┐
│            ViewModel Layer                   │
│  ┌──────────────┐      ┌──────────────┐    │
│  │PlayerViewModel│     │LibraryViewModel│   │
│  └──────────────┘      └──────────────┘    │
└──────────────┬──────────────┬───────────────┘
               │              │
┌──────────────▼──────────────▼───────────────┐
│          Business Logic Layer                │
│  ┌──────────────┐      ┌──────────────┐    │
│  │ExoPlayerMgr  │      │ Repository   │    │
│  └──────────────┘      └──────────────┘    │
└──────────────┬──────────────┬───────────────┘
               │              │
┌──────────────▼──────────────▼───────────────┐
│              Data Layer                      │
│  ┌──────────────┐      ┌──────────────┐    │
│  │   Room DB    │      │     Dao      │    │
│  └──────────────┘      └──────────────┘    │
└──────────────────────────────────────────────┘
```

### 2. 数据流向

```
User Action → UI (Compose) → ViewModel → Repository → Database
                              ↓
                        ExoPlayerManager
                              ↓
                          ExoPlayer
```

### 3. 状态管理

使用 Kotlin Flow 和 StateFlow 实现响应式状态管理：

```kotlin
// ViewModel 中
private val _playbackState = MutableStateFlow<PlaybackState>(PlaybackState.Idle)
val playbackState: StateFlow<PlaybackState> = _playbackState.asStateFlow()

// UI 中
val playbackState by viewModel.playbackState.collectAsState()
```

---

## 核心模块详解

### 1. ExoPlayerManager

**职责**：封装 ExoPlayer 核心功能

**关键方法**：
- `initializePlayer()`: 初始化播放器
- `loadMedia(uri, startPosition)`: 加载媒体
- `play()` / `pause()`: 播放控制
- `seekForward()` / `seekBackward()`: 跳转控制
- `setPlaybackSpeed(speed)`: 倍速控制
- `onLongPressStart()` / `onLongPressEnd()`: 长按加速

**状态管理**：
```kotlin
sealed class PlaybackState {
    object Idle : PlaybackState()
    object Buffering : PlaybackState()
    object Playing : PlaybackState()
    object Paused : PlaybackState()
    object Ended : PlaybackState()
}
```

**倍速记忆机制**：
```kotlin
private var savedSpeed = 1.0f
private var isLongPressing = false

fun onLongPressStart() {
    if (!isLongPressing) {
        isLongPressing = true
        savedSpeed = _playbackSpeed.value  // 保存当前倍速
        setPlaybackSpeed(2.5f)             // 临时 2.5x
    }
}

fun onLongPressEnd() {
    if (isLongPressing) {
        isLongPressing = false
        setPlaybackSpeed(savedSpeed)       // 恢复原倍速
    }
}
```

---

### 2. PlayerViewModel

**职责**：管理播放器 UI 状态和业务逻辑

**核心功能**：
- 播放列表管理
- 播放进度自动保存
- 控制栏显示/隐藏
- 锁屏模式管理

**自动保存位置**：
```kotlin
private fun startAutoSavePosition() {
    savePositionJob?.cancel()
    savePositionJob = viewModelScope.launch {
        while (true) {
            delay(5000)  // 每 5 秒保存一次
            saveCurrentPosition()
        }
    }
}

private fun saveCurrentPosition() {
    val mediaItem = _currentMediaItem.value ?: return
    val position = playerManager.getCurrentPosition()
    viewModelScope.launch {
        repository.updatePosition(mediaItem.id, position)
    }
}
```

---

### 3. 手势处理

使用 Compose 的 `pointerInput` 实现手势检测：

```kotlin
Modifier.pointerInput(Unit) {
    detectTapGestures(
        // 单击：显示/隐藏控制栏
        onTap = {
            if (showControls) hideControls()
            else showControls()
        },
        
        // 双击：快进/快退
        onDoubleTap = { offset ->
            if (offset.x < size.width / 2) {
                seekBackward()  // 左侧后退
            } else {
                seekForward()   // 右侧前进
            }
        },
        
        // 长按：临时加速
        onLongPress = {
            onLongPressStart()
        }
    )
}

// 处理长按释放
Modifier.pointerInput(Unit) {
    detectTapGestures(
        onPress = {
            tryAwaitRelease()
            onLongPressEnd()
        }
    )
}
```

**滑动手势（亮度/音量）**：
```kotlin
Modifier.pointerInput(Unit) {
    detectVerticalDragGestures { change, dragAmount ->
        val x = change.position.x
        val screenWidth = size.width
        
        if (x < screenWidth / 2) {
            // 左半屏：调节亮度
            val delta = -dragAmount / size.height * 0.5f
            brightnessManager.adjustBrightness(delta)
        } else {
            // 右半屏：调节音量
            val delta = (-dragAmount / size.height * 100).toInt()
            volumeManager.adjustVolume(delta)
        }
    }
}
```

---

### 4. Room 数据库

**数据库设计**：

```kotlin
@Database(
    entities = [MediaItem::class, Category::class],
    version = 1
)
abstract class AppDatabase : RoomDatabase() {
    abstract fun mediaItemDao(): MediaItemDao
    abstract fun categoryDao(): CategoryDao
}
```

**查询优化**：

```kotlin
// 使用索引
@Entity(
    tableName = "media_items",
    indices = [
        Index(value = ["lastPlayedTime"]),
        Index(value = ["categoryId"])
    ]
)

// 使用 Flow 实现响应式查询
@Query("SELECT * FROM media_items ORDER BY addedTime DESC")
fun getAllItems(): Flow<List<MediaItem>>
```

---

### 5. 字幕解析

**SRT 格式解析**：

SRT 格式示例：
```
1
00:00:01,500 --> 00:00:04,000
这是第一条字幕

2
00:00:05,000 --> 00:00:08,000
这是第二条字幕
```

解析逻辑：
```kotlin
fun parseSrt(inputStream: InputStream): List<SubtitleEntry> {
    val entries = mutableListOf<SubtitleEntry>()
    val reader = BufferedReader(InputStreamReader(inputStream, Charsets.UTF_8))
    
    var index = 0
    var timeRange = ""
    val textLines = mutableListOf<String>()
    
    reader.useLines { lines ->
        lines.forEach { line ->
            when {
                // 序号行
                line.matches(Regex("\\d+")) -> {
                    index = line.toIntOrNull() ?: 0
                }
                // 时间戳行
                line.contains("-->") -> {
                    timeRange = line
                }
                // 空行：一条字幕结束
                line.trim().isEmpty() -> {
                    if (index > 0) {
                        val (start, end) = parseTimeRange(timeRange)
                        entries.add(SubtitleEntry(index, start, end, textLines.joinToString("\n")))
                    }
                    // 重置
                    index = 0
                    timeRange = ""
                    textLines.clear()
                }
                // 文本行
                else -> {
                    textLines.add(line.trim())
                }
            }
        }
    }
    
    return entries
}
```

**时间戳解析**：
```kotlin
// SRT: 00:01:23,500 → 83500 毫秒
private fun parseTimestamp(timestamp: String): Long {
    val parts = timestamp.split(':', ',')
    val hours = parts[0].toLong()
    val minutes = parts[1].toLong()
    val seconds = parts[2].toLong()
    val millis = parts[3].toLong()
    
    return hours * 3600000 + minutes * 60000 + seconds * 1000 + millis
}
```

---

### 6. 稿件解析

**支持的时间戳格式**：
- `[00:01:23.500]` - 小时:分钟:秒.毫秒
- `[00:01:23]` - 小时:分钟:秒
- `[01:23]` - 分钟:秒

**正则表达式**：
```kotlin
private val timestampRegex = Regex(
    """^\[(\d{1,2}):(\d{2})(?::(\d{2}))?(?:[.,](\d{1,3}))?\]\s*(.*)$"""
)
```

**解析逻辑**：
```kotlin
fun parse(inputStream: InputStream): List<TranscriptEntry> {
    val entries = mutableListOf<TranscriptEntry>()
    val reader = BufferedReader(InputStreamReader(inputStream, Charsets.UTF_8))
    
    var lineNumber = 0
    reader.useLines { lines ->
        lines.forEach { line ->
            lineNumber++
            val match = timestampRegex.find(line.trim())
            
            if (match != null) {
                val timeMs = parseTimestamp(match)
                val text = match.groupValues[5].trim()
                
                entries.add(TranscriptEntry(timeMs, text, lineNumber))
            }
        }
    }
    
    return entries.sortedBy { it.timeMs }
}
```

---

### 7. 后台播放服务

**MediaSessionService 实现**：

```kotlin
class PlaybackService : MediaSessionService() {
    
    private var mediaSession: MediaSession? = null
    private var player: ExoPlayer? = null
    
    override fun onCreate() {
        super.onCreate()
        
        // 初始化播放器
        player = ExoPlayer.Builder(this).build()
        
        // 创建 MediaSession
        mediaSession = MediaSession.Builder(this, player!!)
            .setCallback(MediaSessionCallback())
            .build()
    }
    
    override fun onGetSession(controllerInfo: MediaSession.ControllerInfo): MediaSession? {
        return mediaSession
    }
    
    // MediaSession 回调
    private inner class MediaSessionCallback : MediaSession.Callback {
        override fun onPlay(...) {
            player?.play()
        }
        
        override fun onPause(...) {
            player?.pause()
        }
    }
}
```

**通知栏集成**：

Media3 的 MediaSession 会自动创建通知，包含：
- 封面图片
- 媒体标题
- 播放/暂停按钮
- 上一首/下一首按钮

---

## 性能优化

### 1. 数据库优化

**使用索引**：
```kotlin
@Entity(
    indices = [
        Index(value = ["lastPlayedTime"]),
        Index(value = ["type"]),
        Index(value = ["categoryId"])
    ]
)
```

**分页加载**（未来可扩展）：
```kotlin
@Query("SELECT * FROM media_items ORDER BY addedTime DESC LIMIT :limit OFFSET :offset")
suspend fun getItemsPaged(limit: Int, offset: Int): List<MediaItem>
```

### 2. 内存优化

**及时释放资源**：
```kotlin
override fun onCleared() {
    super.onCleared()
    progressJob?.cancel()
    savePositionJob?.cancel()
    playerManager.release()
}
```

**使用 LazyColumn**：
```kotlin
LazyColumn {
    items(mediaItems) { item ->
        MediaItemCard(item)
    }
}
```

### 3. UI 优化

**避免重组**：
```kotlin
// 使用 remember
val viewModel = remember { PlayerViewModel(...) }

// 使用 key
LazyColumn {
    items(mediaItems, key = { it.id }) { item ->
        MediaItemCard(item)
    }
}
```

---

## 常见问题

### Q1: 如何添加新的倍速选项？

修改 `PlayerControls.kt`：
```kotlin
val speeds = listOf(0.5f, 0.75f, 1.0f, 1.25f, 1.5f, 1.75f, 2.0f, 2.5f, 3.0f)
```

### Q2: 如何修改快进/快退的时长？

修改 `ExoPlayerManager.kt`：
```kotlin
fun seekForward(deltaMs: Long = 30000) {  // 改为 30 秒
    // ...
}
```

### Q3: 如何添加新的手势？

在 `PlayerScreen.kt` 中添加新的手势检测器：
```kotlin
Modifier.pointerInput(Unit) {
    detectHorizontalDragGestures { change, dragAmount ->
        // 处理水平滑动
    }
}
```

### Q4: 如何支持更多字幕格式（如 ASS）？

1. 在 `SubtitleParser.kt` 中添加新的解析方法：
```kotlin
fun parseAss(inputStream: InputStream): List<SubtitleEntry> {
    // ASS 格式解析逻辑
}
```

2. 根据文件扩展名选择解析器：
```kotlin
fun parseSubtitle(file: File): List<SubtitleEntry> {
    return when (file.extension.lowercase()) {
        "srt" -> parseSrt(file.inputStream())
        "vtt" -> parseWebVtt(file.inputStream())
        "ass" -> parseAss(file.inputStream())
        else -> emptyList()
    }
}
```

### Q5: 如何添加播放列表循环模式？

1. 在 `PlayerViewModel` 中添加循环模式状态：
```kotlin
enum class RepeatMode {
    NONE,      // 不循环
    ONE,       // 单曲循环
    ALL        // 列表循环
}

private val _repeatMode = MutableStateFlow(RepeatMode.NONE)
val repeatMode: StateFlow<RepeatMode> = _repeatMode.asStateFlow()
```

2. 在播放结束时根据模式处理：
```kotlin
override fun onPlaybackStateChanged(state: Int) {
    if (state == Player.STATE_ENDED) {
        when (_repeatMode.value) {
            RepeatMode.ONE -> {
                player?.seekTo(0)
                player?.play()
            }
            RepeatMode.ALL -> {
                playNext()
            }
            RepeatMode.NONE -> {
                // 不做处理
            }
        }
    }
}
```

---

## 调试技巧

### 1. 查看播放器状态

添加日志：
```kotlin
player?.addListener(object : Player.Listener {
    override fun onPlaybackStateChanged(state: Int) {
        Log.d("Player", "State: ${stateToString(state)}")
    }
    
    override fun onPlayerError(error: PlaybackException) {
        Log.e("Player", "Error: ${error.message}", error)
    }
})
```

### 2. 检查数据库

使用 Android Studio 的 Database Inspector：
- View → Tool Windows → App Inspection
- 选择 Database Inspector
- 查看表内容和执行查询

### 3. 性能分析

使用 Android Profiler：
- View → Tool Windows → Profiler
- 监控 CPU、内存、网络使用

---

## 代码规范

### 1. 命名规范

- **类名**: PascalCase (如 `PlayerViewModel`)
- **函数名**: camelCase (如 `loadMedia()`)
- **变量名**: camelCase (如 `currentPosition`)
- **常量**: UPPER_SNAKE_CASE (如 `MAX_SPEED`)

### 2. 文件组织

```kotlin
// 1. Package 声明
package com.local.mediaplayer.player

// 2. Import 语句
import androidx.compose.runtime.*
import kotlinx.coroutines.flow.*

// 3. 常量
private const val TAG = "ExoPlayerManager"

// 4. 类定义
class ExoPlayerManager {
    // 4.1 属性
    private val player: ExoPlayer
    
    // 4.2 初始化块
    init { }
    
    // 4.3 公共方法
    fun play() { }
    
    // 4.4 私有方法
    private fun updateState() { }
}
```

### 3. 注释规范

```kotlin
/**
 * ExoPlayer 管理器
 * 
 * 封装 ExoPlayer 核心功能，提供播放控制、倍速、跳转等功能。
 * 
 * @param context Android 上下文
 */
class ExoPlayerManager(private val context: Context) {
    
    /**
     * 设置播放速度
     * 
     * @param speed 播放速度（0.25 - 3.0）
     */
    fun setPlaybackSpeed(speed: Float) {
        // ...
    }
}
```

---

## 版本发布流程

### 1. 更新版本号

修改 `app/build.gradle.kts`：
```kotlin
defaultConfig {
    versionCode = 2      // 每次递增
    versionName = "1.1.0" // 语义化版本
}
```

### 2. 更新 CHANGELOG

创建 `CHANGELOG.md`：
```markdown
## [1.1.0] - 2025-01-15

### 新增
- 支持 ASS 字幕格式
- 添加播放列表循环模式

### 改进
- 优化播放器性能
- 改进 UI 响应速度

### 修复
- 修复进度保存问题
- 修复横竖屏切换卡顿
```

### 3. 打包 Release

```bash
./gradlew assembleRelease
```

### 4. 测试

在至少 3 个不同版本的 Android 设备上测试。

### 5. 发布

- 上传到 GitHub Releases
- 更新 README
- 通知用户

---

**文档版本**: v1.0  
**最后更新**: 2025-12-23  
**维护者**: 开发团队

